<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js coal">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Notes</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Notes on learning Rust programming language.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "coal";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('coal')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Readme</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">3.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">4.</strong> References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#rust-uml2-statemachine" id="rust-uml2-statemachine">Rust UML2 StateMachine</a></h1>
<p>A UML2 StateMachine implemenation in Rust programming language.</p>
<h2><a class="header" href="#goals" id="goals">Goals</a></h2>
<ul>
<li>full support for UML 2.x specification</li>
</ul>
<h2><a class="header" href="#building-the-associated-book" id="building-the-associated-book">Building the associated Book</a></h2>
<p>Along with documentation as part of the source code, there is a markdown book in this repo.
This book is generated using the handy mdbook crate, and published on github.io.</p>
<ul>
<li>Build/View the book locally: <code>mdbook build --open</code></li>
<li>Rebuild/View loop: <code>mdbook watch --open</code></li>
</ul>
<h2><a class="header" href="#documentation" id="documentation">Documentation</a></h2>
<ul>
<li>View the book:  <a href="https://joemooney.github.io/rust-uml-sm/">https://joemooney.github.io/rust-uml-sm/</a></li>
<li>Source code: <a href="https://github.com/joemooney/rust-uml-sm/">https://github.com/joemooney/rust-uml-sm/</a>
-- View the book locally: <a href="file:///home/jpm/rust/rust-uml-sm/book/index.html">file:///home/jpm/rust/rust-uml-sm/book/index.html</a></li>
</ul>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p><sub><span style='color:gray'><em>Last Updated: 2020-09-12 23:48:41</em></span></sub></p>
<p>This book contains notes on how to use the rust-uml-sm module to create UML2 state machines.</p>
<p>In order to create this book and play around with Rust, I have used the following tools:</p>
<ul>
<li>rust
<ul>
<li>cargo
<ul>
<li>mdbook</li>
</ul>
</li>
</ul>
</li>
<li>GitHub
<ul>
<li>GitHub Pages</li>
</ul>
</li>
<li>hub</li>
<li>git</li>
<li>rsync</li>
<li>VS Code
<ul>
<li>Extensions (listing ones I like and use, not all needed for this books)
<ul>
<li>docs-markdown :star: Alt-M to see help</li>
<li>Git Graph</li>
<li>GitLens</li>
<li>Rust</li>
<li>TabNine</li>
<li>Vim</li>
</ul>
</li>
</ul>
</li>
<li>Firefox
<ul>
<li>Extensions
<ul>
<li>vimium - navigate in browser like Vim</li>
</ul>
</li>
</ul>
</li>
<li>Linux
<ul>
<li>terminator</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#statemachine-concepts" id="statemachine-concepts">Statemachine Concepts</a></h1>
<p>This is officially defined here https://www.omg.org/spec/UML/2.5.1/PDF by UML.org</p>
<p>I will rephrase their words here.</p>
<p>Simple State: a state without internal Vertices or Transitions.
Composite State: a state with at least one Region.
Submachine State: a state referencing to another StateMachine, basically a definition of a non-simple state and this submachine state expands or is replaced to that other definition.
Simple composite State: has exactly one Region
Orthogonal State: has multiple Regions (isOrthogonal = true).</p>
<p>Substate: a State enclosed within a Region of a composite State is called a
substate of that composite State.
Direct Substate: a substate of a region but not nested in another substate;
Indirect substate: a nested substate of a region.</p>
<p>A StateMachine itself can have multiple Regions, each of which may contain States of its own, some of which maybe composites with their own multiple Regions, etc. Consequently,
Active State: For a region or composite state, the particular substate to which we have currently transitioned.
Active State Configuration: Recursively, the active states for all regions.</p>
<p>In simple terms a StateMachine execution involves transitions from one state to another.
Technically, because a statemachine can be more complex than a simple Finite State Machine, the execution involves the transitions from one &quot;active state configuration&quot; to another.</p>
<p>Events are either generated internally or externally.
The state machine operates an event loop processing each event in sequence.
For each event we check all the active states to see if they have any transitions
defined that trigger on the current event.
That means that the event type is the same for the transition and any
guard defined for the transition evaluates to true.
We work from the innermost transition that is associated with the trigger, to
the outter most state that has an potential transition. The innermost takes
precedence. If there are multiple transitions that may trigger in sibling
orthogonal regions, it is considered an error in the definition of the 
state machine. The state machine should be defined in such a way that there
are no ambiguous transitions potentially possible.</p>
<p>&quot;&quot;&quot; uml.org
A transition is in response to an Event occurrence.
Each transition that match the Triggers of the StateMachine.
A State is said to be active if it is part of the active state configuration.
A state configuration is said to be stable when: no further Transitions from 
that state configuration are enabled and all the entry Behaviors of that configuration,
if present, have completed (but not necessarily the doActivityBehaviors of that configuration,
which, if defined, may continue executing).
After it has been created and completed its initial Transition, a StateMachine is always “in” some state configuration. 
However, because States can be hierarchical and because there
can be Behaviors associated with both Transitions and States,
“entering” a hierarchical state configuration involves a dynamic
process that terminates only after a stable state configuration
(as defined above) is reached. This creates some potential ambiguity
as to precisely when a StateMachine is “in” a particular state within
a state configuration. The rules for when a StateMachine is deemed to
be “in” a State and when it is deemed to have “left” a State are
described below in the sections “Entering a State” and “Exiting a
State respectively.
A configuration is deemed stable even if there are deferred, completion,
or any other types of Event occurrences pending in the event pool
of that StateMachine
State may have an associated entry Behavior.
This Behavior, if defined, is executed whenever the State is entered
through an externalTransition. In addition, a State may also have an
associated exit Behavior, which, if defined, is executed whenever the
State is exited.A State may also have an associated doActivity Behavior.
This Behavior commences execution when the State is entered (but only
after the State entry Behavior has completed) and executes concurrently
with any other Behaviors that may be associated with the State,
until: it completes (in which case a completion event is generated) or
the State is exited, in which case execution of the doActivity Behavior 
is aborted.
The execution of a doActivity Behavior of a State is not
affected by the firing of an internalTransition of that State
The concept of State history was introduced by David Harel in
the original statechart formalism. It is a convenience concept
associated with Regions of composite States whereby a Region keeps
track of the state configuration it was in when it was last exited.
This allows easy return to that same state configuration, if desired,
the next time the Region becomes active (e.g., after returning from
handling an interrupt), or if there is a local Transition that
returns to its history. This is achieved simply by terminating a
Transition on the desired type of history Pseudostate inside the
Region.The advantage provided by this facility is that it eliminates
the need for users to explicitly keep track of history in cases where
this type of behavior is desired, which can result in significantly
simpler state machine models.Two types of history Pseudostates are
provided. Deep history (deepHistory) represents the full state
configuration of the most recent visit to the containing Region.
The effect is the same as if the Transition terminating on the
deepHistoryPseudostate had, instead, terminated on the innermost
State of the preserved state configuration, including execution of
all entry Behaviors encountered along the way. Shallow history
(shallowHistory) represents a return to only the topmost substate
of the most recent state configuration, which is entered using the
default entry rule.In cases where a Transition terminates on a history
Pseudostate when the State has not been entered before
(i.e., no priorhistory) or it had reached its FinalState, there is
an option to force a transition to a specific substate, using the
default history mechanism. This is a Transition that originates in
the history Pseudostate and terminates on a specific Vertex (the
efault history state) of the Region containing the history Pseudostate.
This Transition is only taken if execution leads tothe history
Pseudostate and the State had never been active before. Otherwise,
the appropriate history entry into the Region is executed (see above).
If no default history Transition is defined, then standard default
entry of the Region is performed as explained below.Deferred Events A State may specify a set of Event types that may be deferred in that State. This means that Event occurrences of those types will not be dispatched as long as that State remains active. Instead, these Event occurrences remain in the event pool until:a state configuration is reached where these Event types are no longer deferred or,if a deferred Event type is used explicitly in a Trigger of a Transition whose source is the deferring State (i.e., akind of override option).An Event may be deferred by a composite State or submachine States, in which case it remains deferred as long as the composite State remains in the active configuration.
The semantics of entering a State depend on the type of State and the manner in which it is entered. However, in all cases, the entry Behavior of the State is executed (if defined) upon entry, but only after any effect Behavior associated
with the incoming Transition is completed.
Also, if a doActivity Behavior is defined for the State,
this Behavior commences execution immediately after the entry
Behavior is executed. It executes concurrently with any subsequent
Behaviors associated with entering the State, such as the entry
Behaviors of substates entered as part of the same compound transition.
The above description fully covers the case of simple States.
For composite States with a single Region the following
alternatives exist:
Default entry: This situation occurs when the composite State is
the direct target of a Transition (graphically, this is indicated
by an incoming Transition that terminates on the outside edge of
the composite State). After executing the entry Behavior and
forking a possible doActivity Behavior execution, if an initial
Pseudostate is defined, State entry continues from that Vertex
via its outgoing Transition (known as the default Transition of
the State).
If no initial Pseudostate is defined, there is no single approach defined.
One alternative is to treat such a model as ill formed.
A second alternative is to treat the composite State as a simple State,
terminating the traversal on that State despite its internal parts.
Explicit entry: If the incoming Transition or its continuations
terminate on a directly contained substate of the composite State,
then that substate becomes active and its entry Behavior is executed
after the execution of the entry Behavior of the containing composite
State.
This rule applies recursively if the Transition terminates on an
indirect (deeply nested) substate.
Shallow history entry: If the incoming Transition terminates on a
shallowHistory Pseudostate of a Region of the composite State,
the active substate becomes the substate that was most recently
active prior to this entry, unless:othe most recently active
substate is the FinalState, oro this is the first entry into
this State.oIn the latter two cases, if a default shallow history
Transition is defined originating from the shallowHistory Pseudostate,
it will be taken. Otherwise, default State entry is applied.
Deep history entry: The rule for this case is the same as for shallow
history except that the target Pseudostate is of type deepHistory
and the rule is applied recursively to all levels in the active
state configuration below this one.
Entry point entry: If a Transition enters a composite State through
an entryPointPseudostate, then the effectBehavior associated with
the outgoing Transition originating from the entry point and
penetrating into the State(but after the entry Behavior of the
composite State has been executed).If the composite State is also
an orthogonal State with multiple Regions, each of its Regions is
also entered, either by default or explicitly. If the Transition
terminates on the edge of the composite State (i.e., without entering
the State), then all the Regions are entered using the default entry
rule above. If the Transition explicitly enters one or more Regions
(in case of a fork), these Regions are entered explicitly and the
others by default.Regardless of how a State is entered, the
StateMachine is deemed to be “in” that State even before any
entry Behavior oreffect Behavior (if defined) of that State
start executing.
When exiting a State, regardless of whether it is simple or composite,
the final step involved in the exit, after all other Behaviors
associated with the exit are completed, is the execution of the exit
Behavior of that State. If the State has a doActivity Behavior that
is still executing when the State is exited, that Behavior is aborted
before the exit Behavior commences execution.When exiting from a
composite State, exit commences with the innermost State in the active
state configuration. This means that exit Behaviors are executed in
sequence starting with the innermost active State. If the exit occurs
through anexitPointPseudostate, then the exit Behavior of the State is
executed after the effect Behavior of the Transition terminating on
the exit point.
When exiting from an orthogonal State, each of its Regions is exited.
After that, the exit Behavior of the State is executed.Regardless of how
a State is exited, the StateMachine is deemed to have “left” that State
only after the exit Behavior (if defined) of that State has completed
execution.Encapsulated composite StatesIn some modeling situations, it
is useful to encapsulate a composite State, by not allowing Transitions
to penetrate directly into the State to terminate on one of its internal
Vertices. (One common use case for this is when the internals ofa State
in an abstract Classifier are intended to be specified differently in
different subtype refinements of the abstract Classifier.) Despite the
encapsulation, it is often necessary to bind the internal elements of
the composite State with incoming and outgoing Transitions. This is done
by means of entry and exit points, which are realized via the entryPoint
and exitPointPseudostates.Entry points represent termination points
(sources) for incoming Transitions and origination points (targets)
for Transitions that terminate on some internal Vertex of the composite
State. In effect, the latter is a continuation of the external incoming
Transition, with the proviso that the execution of the entry Behavior
of the composite State (if defined) occurs between the effect Behavior
of the incoming Transition and the effect Behavior of the outgoing
Transition. If there is no outgoing Transition inside the composite State,
then the incoming Transition simply performs adefault State entry.
Exit points are the inverse of entry points. That is, Transitions
originating from a Vertex within the composite State can terminate on
the exit point. In a well-formed model, such a Transition should have
a corresponding external Transition outgoing from the same exit point,
representing a continuation of the terminating Transition. If the
composite State has an exit Behavior defined, it is executed after
any effect Behavior of the incoming inside Transition and before any
effectBehavior of the outgoing external Transition.
Submachines are a means by which a single StateMachine specification can be reused multiple times. They are similar to encapsulated composite States in that they need to bind incoming and outgoing Transitions to their internal Vertices. However, whereas encapsulated composite States and their internals are contained within the StateMachine in which they are defined, submachines are, like programming language macros, distinct Behavior specifications, which may be defined in a different context than the one where they are used (invoked). Consequently, they require a more complex binding. This is achieved through the concept of submachine State (i.e., States with isSubmachineState = true), which represent references to corresponding submachine StateMachines. The concept of ConnectionPointReference is provided to support binding between the submachine State and the referenced StateMachine. A ConnectionPointReference represents a point on the submachine State at which a Transition either terminates or originates. That is, they serve as targets for incoming Transitions to submachine States, as well as sources for outgoing Transitions from submachine States. Each ConnectionPointReference is matched by a corresponding entry or exit point in the referenced submachine StateMachine. This provides the necessary binding mechanism between the submachine invocation and its specification.A submachine State implies a macro-like insertion of the specification of the corresponding submachine StateMachine. It is, therefore, semantically equivalent to a composite State. The Regions of the submachine StateMachine are the Regions of the composite State. The entry, exit, and effect Behaviors and internal Transitions are defined as contained in the submachine State.NOTE. Each submachine State represents a distinct instantiation of a submachine, even when two or more submachine States reference the same submachine.A submachine StateMachine can be entered via its default (initial) Pseudostate or via any of its entry points (i.e., it may imply entering a non-orthogonal or an orthogonal composite State with Regions). Entering via the initial Pseudostate hasthe same meaning as for ordinary composite States. An entry point is equivalent to a junctionPseudostate (forkin cases where the composite State is orthogonal): Entering via an entry point implies that the entry Behavior of the composite state is executed, followed by the Transition from the entry point to the target Vertex within the composite State. Any guards associated with these entry point Transitions must evaluate to true in order for the specification to be well formed.alloc</p>
<p>Similarly, a submachine Statemachine can be exited as a result of:
reaching its FinalState, triggering of a group Transition originating
from a submachine State, or via any of its exit points.Exiting via a
FinalState or by a group Transition has the same meaning as for ordinary composite States.
&quot;&quot;&quot;</p>
<h1><a class="header" href="#references" id="references">References</a></h1>
<ul>
<li><a href="https://doc.rust-lang.org/book/title-page.html">Rust Book</a></li>
<li><a href="https://rust-lang-nursery.github.io/rust-cookbook/">Rust Cookbook</a></li>
<li><a href="https://play.rust-lang.org">Rust Playground</a></li>
<li><a href="https://www.tutorialspoint.com/rust/index.htm">Rust Tutorial</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example">Rust By Example</a></li>
<li><a href="https://nikolaivazquez.com/rust-workshop/#1">Rust Powerpoint</a></li>
</ul>
<h2><a class="header" href="#excercises" id="excercises">Excercises</a></h2>
<ul>
<li><a href="https://projecteuler.net/">Project Euler</a>
<ul>
<li>No solutions, just do these exercises as practice.</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
